// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: safe.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Safe.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - SafeRoot

@implementation SafeRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - SafeRoot_FileDescriptor

static GPBFileDescriptor *SafeRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - RegisterData

@implementation RegisterData

@dynamic hasVersion, version;
@dynamic hasAdminAddress, adminAddress;
@dynamic hasAppName, appName;
@dynamic hasAppDesc, appDesc;
@dynamic hasDevType, devType;
@dynamic hasDevName, devName;
@dynamic hasWebURL, webURL;
@dynamic hasLogoURL, logoURL;
@dynamic hasCoverURL, coverURL;

typedef struct RegisterData__storage_ {
  uint32_t _has_storage_[1];
  NSData *version;
  NSData *adminAddress;
  NSData *appName;
  NSData *appDesc;
  NSData *devType;
  NSData *devName;
  NSData *webURL;
  NSData *logoURL;
  NSData *coverURL;
} RegisterData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = RegisterData_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RegisterData__storage_, version),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "adminAddress",
        .dataTypeSpecific.className = NULL,
        .number = RegisterData_FieldNumber_AdminAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RegisterData__storage_, adminAddress),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "appName",
        .dataTypeSpecific.className = NULL,
        .number = RegisterData_FieldNumber_AppName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RegisterData__storage_, appName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "appDesc",
        .dataTypeSpecific.className = NULL,
        .number = RegisterData_FieldNumber_AppDesc,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RegisterData__storage_, appDesc),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "devType",
        .dataTypeSpecific.className = NULL,
        .number = RegisterData_FieldNumber_DevType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RegisterData__storage_, devType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "devName",
        .dataTypeSpecific.className = NULL,
        .number = RegisterData_FieldNumber_DevName,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RegisterData__storage_, devName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "webURL",
        .dataTypeSpecific.className = NULL,
        .number = RegisterData_FieldNumber_WebURL,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RegisterData__storage_, webURL),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "logoURL",
        .dataTypeSpecific.className = NULL,
        .number = RegisterData_FieldNumber_LogoURL,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RegisterData__storage_, logoURL),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "coverURL",
        .dataTypeSpecific.className = NULL,
        .number = RegisterData_FieldNumber_CoverURL,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(RegisterData__storage_, coverURL),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RegisterData class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RegisterData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\002\014\000\003\007\000\004\007\000\005\007\000\006\007\000\007\004!!\000\010\005!!\000\t\006!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AuthData

@implementation AuthData

@dynamic hasVersion, version;
@dynamic hasSetType, setType;
@dynamic hasAdminAddress, adminAddress;
@dynamic hasUserAddress, userAddress;
@dynamic hasAuth, auth;

typedef struct AuthData__storage_ {
  uint32_t _has_storage_[1];
  uint32_t auth;
  NSData *version;
  NSData *setType;
  NSData *adminAddress;
  NSData *userAddress;
} AuthData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = AuthData_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AuthData__storage_, version),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "setType",
        .dataTypeSpecific.className = NULL,
        .number = AuthData_FieldNumber_SetType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AuthData__storage_, setType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "adminAddress",
        .dataTypeSpecific.className = NULL,
        .number = AuthData_FieldNumber_AdminAddress,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AuthData__storage_, adminAddress),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "userAddress",
        .dataTypeSpecific.className = NULL,
        .number = AuthData_FieldNumber_UserAddress,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AuthData__storage_, userAddress),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "auth",
        .dataTypeSpecific.className = NULL,
        .number = AuthData_FieldNumber_Auth,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AuthData__storage_, auth),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AuthData class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuthData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\002\007\000\003\014\000\004\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ExtendData

@implementation ExtendData

@dynamic hasVersion, version;
@dynamic hasAuth, auth;
@dynamic hasExtendData, extendData;

typedef struct ExtendData__storage_ {
  uint32_t _has_storage_[1];
  uint32_t auth;
  NSData *version;
  NSData *extendData;
} ExtendData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = ExtendData_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExtendData__storage_, version),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "auth",
        .dataTypeSpecific.className = NULL,
        .number = ExtendData_FieldNumber_Auth,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ExtendData__storage_, auth),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "extendData",
        .dataTypeSpecific.className = NULL,
        .number = ExtendData_FieldNumber_ExtendData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ExtendData__storage_, extendData),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ExtendData class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExtendData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IssueData

@implementation IssueData

@dynamic hasVersion, version;
@dynamic hasShortName, shortName;
@dynamic hasAssetName, assetName;
@dynamic hasAssetDesc, assetDesc;
@dynamic hasAssetUnit, assetUnit;
@dynamic hasTotalAmount, totalAmount;
@dynamic hasFirstIssueAmount, firstIssueAmount;
@dynamic hasFirstActualAmount, firstActualAmount;
@dynamic hasDecimals, decimals;
@dynamic hasDestory, destory;
@dynamic hasPayCandy, payCandy;
@dynamic hasCandyAmount, candyAmount;
@dynamic hasCandyExpired, candyExpired;
@dynamic hasRemarks, remarks;

typedef struct IssueData__storage_ {
  uint32_t _has_storage_[1];
  NSData *version;
  NSData *shortName;
  NSData *assetName;
  NSData *assetDesc;
  NSData *assetUnit;
  NSData *decimals;
  NSData *candyExpired;
  NSData *remarks;
  int64_t totalAmount;
  int64_t firstIssueAmount;
  int64_t firstActualAmount;
  int64_t candyAmount;
} IssueData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = IssueData_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IssueData__storage_, version),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "shortName",
        .dataTypeSpecific.className = NULL,
        .number = IssueData_FieldNumber_ShortName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IssueData__storage_, shortName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "assetName",
        .dataTypeSpecific.className = NULL,
        .number = IssueData_FieldNumber_AssetName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IssueData__storage_, assetName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "assetDesc",
        .dataTypeSpecific.className = NULL,
        .number = IssueData_FieldNumber_AssetDesc,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(IssueData__storage_, assetDesc),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "assetUnit",
        .dataTypeSpecific.className = NULL,
        .number = IssueData_FieldNumber_AssetUnit,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(IssueData__storage_, assetUnit),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "totalAmount",
        .dataTypeSpecific.className = NULL,
        .number = IssueData_FieldNumber_TotalAmount,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(IssueData__storage_, totalAmount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "firstIssueAmount",
        .dataTypeSpecific.className = NULL,
        .number = IssueData_FieldNumber_FirstIssueAmount,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(IssueData__storage_, firstIssueAmount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "firstActualAmount",
        .dataTypeSpecific.className = NULL,
        .number = IssueData_FieldNumber_FirstActualAmount,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(IssueData__storage_, firstActualAmount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "decimals",
        .dataTypeSpecific.className = NULL,
        .number = IssueData_FieldNumber_Decimals,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(IssueData__storage_, decimals),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "destory",
        .dataTypeSpecific.className = NULL,
        .number = IssueData_FieldNumber_Destory,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "payCandy",
        .dataTypeSpecific.className = NULL,
        .number = IssueData_FieldNumber_PayCandy,
        .hasIndex = 11,
        .offset = 12,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "candyAmount",
        .dataTypeSpecific.className = NULL,
        .number = IssueData_FieldNumber_CandyAmount,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(IssueData__storage_, candyAmount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "candyExpired",
        .dataTypeSpecific.className = NULL,
        .number = IssueData_FieldNumber_CandyExpired,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(IssueData__storage_, candyExpired),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "remarks",
        .dataTypeSpecific.className = NULL,
        .number = IssueData_FieldNumber_Remarks,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(IssueData__storage_, remarks),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IssueData class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IssueData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\n\002\t\000\003\t\000\004\t\000\005\t\000\006\013\000\007\020\000\010\021\000\013\010\000\014\013\000\r\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CommonData

@implementation CommonData

@dynamic hasVersion, version;
@dynamic hasAssetId, assetId;
@dynamic hasAmount, amount;
@dynamic hasRemarks, remarks;

typedef struct CommonData__storage_ {
  uint32_t _has_storage_[1];
  NSData *version;
  NSData *assetId;
  NSData *remarks;
  int64_t amount;
} CommonData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = CommonData_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CommonData__storage_, version),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "assetId",
        .dataTypeSpecific.className = NULL,
        .number = CommonData_FieldNumber_AssetId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CommonData__storage_, assetId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = CommonData_FieldNumber_Amount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CommonData__storage_, amount),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "remarks",
        .dataTypeSpecific.className = NULL,
        .number = CommonData_FieldNumber_Remarks,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CommonData__storage_, remarks),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CommonData class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CommonData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PutCandyData

@implementation PutCandyData

@dynamic hasVersion, version;
@dynamic hasAssetId, assetId;
@dynamic hasAmount, amount;
@dynamic hasExpired, expired;
@dynamic hasRemarks, remarks;

typedef struct PutCandyData__storage_ {
  uint32_t _has_storage_[1];
  NSData *version;
  NSData *assetId;
  NSData *expired;
  NSData *remarks;
  int64_t amount;
} PutCandyData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = PutCandyData_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PutCandyData__storage_, version),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "assetId",
        .dataTypeSpecific.className = NULL,
        .number = PutCandyData_FieldNumber_AssetId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PutCandyData__storage_, assetId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = PutCandyData_FieldNumber_Amount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PutCandyData__storage_, amount),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "expired",
        .dataTypeSpecific.className = NULL,
        .number = PutCandyData_FieldNumber_Expired,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PutCandyData__storage_, expired),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "remarks",
        .dataTypeSpecific.className = NULL,
        .number = PutCandyData_FieldNumber_Remarks,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PutCandyData__storage_, remarks),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PutCandyData class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PutCandyData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetCandyData

@implementation GetCandyData

@dynamic hasVersion, version;
@dynamic hasAssetId, assetId;
@dynamic hasAmount, amount;
@dynamic hasRemarks, remarks;

typedef struct GetCandyData__storage_ {
  uint32_t _has_storage_[1];
  NSData *version;
  NSData *assetId;
  NSData *remarks;
  int64_t amount;
} GetCandyData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = GetCandyData_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetCandyData__storage_, version),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "assetId",
        .dataTypeSpecific.className = NULL,
        .number = GetCandyData_FieldNumber_AssetId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetCandyData__storage_, assetId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = GetCandyData_FieldNumber_Amount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetCandyData__storage_, amount),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "remarks",
        .dataTypeSpecific.className = NULL,
        .number = GetCandyData_FieldNumber_Remarks,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetCandyData__storage_, remarks),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetCandyData class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetCandyData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
